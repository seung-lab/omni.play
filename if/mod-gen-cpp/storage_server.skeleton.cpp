// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../../storage_server.hpp"
#include "storage_server.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include "storage_manager.h"
#include "simple_client.hpp"
#include <zi/system.hpp>
#include <zi/arguments.hpp>
#include <zi/system/daemon.hpp>
#include <iostream>
#include <cstddef>
#include <map>

ZiARG_bool(daemonize, true, "Run as daemon");
ZiARG_string(id, "server1", "Server's ID");
ZiARG_uint64(size, 1024*1024*1024, "Size");
ZiARG_string(manager, "localhost", "Manager's IP");
ZiARG_int32(port, 9091, "Server's port");
ZiARG_int32(m_port, 9090, "Manager's port");

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;


class storage_serverHandler : virtual public bint::storage_serverIf {

private:
    storage_server<std::string,char> server_;
    bint::server_id id_;

public:
    storage_serverHandler(std::string id, size_t size, std::string manager, int port, int m_port)
        : server_(id,size), //initialize storage_server
	  id_()
    {
	// Your initialization goes here
	id_.address = zi::system::get_hostname();
	id_.port = port;

	//register with storage manager service
	boost::shared_ptr<bint::storage_managerClient> client =
	    ThriftFactory<bint::storage_managerClient>::getClient(manager, m_port);

	client->register_server(id_);
    }

    void get_stats(std::map<std::string,int64_t>& _return)
    {
        _return.clear();
        _return["FileSize"] = server_.get_size();
        _return["FreeMemory"] = server_.get_free_memory();
        _return["UsedMemory"] = server_.get_size() - server_.get_free_memory();
    }

    void get(std::string& _return, const std::string& key) {
        // Your implementation goes here
        //printf("get\n");
	storage_type<char> val = server_.get(key);
	_return.assign(val.data,val.size);
    }

    bool put(const std::string& key, const std::string& value) {
        // Your implementation goes here
        //printf("put\n");
        //construct storage_type
	storage_type<char> val;
	//this is ok since the server stores a copy of val
	val.data = const_cast<char*>(value.c_str());
	//TODO check that this works right, might be +1
	val.size = value.size();

	return server_.set(key,val);

    }

};

int main(int argc, char **argv) {

    zi::parse_arguments(argc, argv, true);
    int port = ZiARG_port;


    std::cout << zi::system::get_hostname() << ".local:"<<port <<" \n";

    ::boost::shared_ptr<storage_serverHandler> handler
          (new storage_serverHandler(ZiARG_id, ZiARG_size, ZiARG_manager, ZiARG_port, ZiARG_m_port));
    ::boost::shared_ptr<TProcessor> processor(new bint::storage_serverProcessor(handler));
    ::boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

    if ( ZiARG_daemonize )
    {
        zi::system::daemonize(true,true);
    }

    server.serve();
    return 0;
}



