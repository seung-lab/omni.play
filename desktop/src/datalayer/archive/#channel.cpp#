#include "coordinates/yaml.h"
#include "yaml-cpp/yaml.h"
#include "project/details/omChannelManager.h"
#include "utility/yaml/mipVolume.hpp"
#include "utility/yaml/baseTypes.hpp"
#include "datalayer/archive/filter.h"
#include "utility/yaml/genericManager.hpp"

#include "common_yaml.hpp"

namespace YAML {

template<class T>
void operator>>(const YAML::Node& in, std::set<T>& s)
{
    FOR_EACH(it, in)
    {
        T item;
        *it >> item;
        s.insert(item);
    }
}

template<class T>
YAML::Emitter &operator<<(YAML::Emitter& out, const std::unordered_set<T>& s)
{
    out << YAML::Flow << YAML::BeginSeq;
    for(const auto& e : s){
        out << e;
    }
    out << YAML:: EndSeq;
    return out;
}

template<class T>
void operator>>(const YAML::Node& in, std::unordered_set<T>& s)
{
    FOR_EACH(it, in)
    {
        T item;
        *it >> item;
        s.insert(item);
    }
}

void operator>>(const YAML::Node& in, uint32_t& p){
    p = in.as<uint32_t>();
}

void operator>>(const YAML::Node& in, int& p){
    p = in.as<int>();
}

void operator>>(const YAML::Node& in, double& p){
    p = in.as<double>();
}

template<class Key, class T>
void operator>>(const YAML::Node& in, QHash<Key, T>& p)
{
    for(const auto& kv : p){
        Key key;
        T value;
        kv.first >> key;
        kv.second >> value;
        p.insert(key, value);
    }
}

template<class Key, class T>
YAML::Emitter &operator<<(YAML::Emitter& out, const QHash<Key, T>& p)
{
    out << YAML::BeginMap;
    FOR_EACH(it, p)
    {
        out << YAML::Key << it.key();
        out << YAML::Value << it.value();
    }
    out << YAML::EndMap;

    return out;
}


Emitter &operator<<(Emitter& out, const OmChannelManager& cm)
{
    out << BeginMap;
    genericManager::Save(out, cm.manager_);
    out << EndMap;
    return out;
}

void operator>>(const Node& in, OmChannelManager& cm)
{
    genericManager::Load(in, cm.manager_);
}

Emitter& operator<<(Emitter& out, const OmChannel& chan)
{
    out << BeginMap;
    mipVolume<const OmChannel> volArchive(chan);
    volArchive.Store(out);

    out << Key << "Filters" << Value << chan.filterManager_;
    out << EndMap;
    return out;
}

void operator>>(const Node& in, OmChannel& chan)
{
    mipVolume<OmChannel> volArchive(chan);
    volArchive.Load(in);

    in["Filters"] >> chan.filterManager_;
    chan.LoadVolDataIfFoldersExist();
}

template<class T>
YAML::Emitter &operator<<(YAML::Emitter& out, const Vector3<T>& p)
{
    out << YAML::Flow;
    out << YAML::BeginSeq << p.x << p.y << p.z << YAML::EndSeq;
    return out;
}

template<class T>
void operator>>(const YAML::Node& in, Vector3<T>& p)
{
    in[0] >> p.x;
    in[1] >> p.y;
    in[2] >> p.z;
}

Emitter& operator<<(Emitter& out, const OmMipVolCoords& c)
{
    out << BeginMap;
    out << Key << "dataDimensions" << Value << c.GetDataDimensions();
    out << Key << "dataResolution" << Value << c.GetResolution();
    out << Key << "chunkDim" << Value << c.chunkDim_;
    out << Key << "mMipLeafDim" << Value << c.mMipLeafDim;
    out << Key << "mMipRootLevel" << Value << c.mMipRootLevel;
    out << Key << "absOffset" << Value << c.GetAbsOffset();
    out << EndMap;
    return out;
}

void operator>>(const Node& in, OmMipVolCoords& c)
{
    if(in["dataExtent"]){
        om::globalBbox extent;
        in["dataExtent"] >> extent;
        // backwards compatibility
        c.SetDataDimensions(extent.getDimensions());
    } else {
        Vector3i dims;
        in["dataDimensions"] >> dims;
        c.SetDataDimensions(dims);
    }

    Vector3i resolution;
    in["dataResolution"] >> resolution;
    c.SetResolution(resolution);

    in["chunkDim"] >> c.chunkDim_;
    in["mMipLeafDim"] >> c.mMipLeafDim;
    in["mMipRootLevel"] >> c.mMipRootLevel;

    Vector3i offset;
    if(in["absOffset"]){
        in >> offset;
    } else {
        offset = Vector3i::ZERO;
    }
    c.SetAbsOffset(offset);
}

} // namespace YAML
