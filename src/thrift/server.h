/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef server_H
#define server_H

#include <TProcessor.h>
#include "server_types.h"

namespace om { namespace server {

class serverIf {
 public:
  virtual ~serverIf() {}
  virtual void get_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view) = 0;
  virtual void get_tiles(std::map<std::string, tile> & _return, const metadata& vol, const bbox& bounds, const viewType::type view, const value& filter) = 0;
  virtual void get_value(value& _return, const metadata& vol, const vector3d& point) = 0;
  virtual void get_values(std::set<value> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view) = 0;
  virtual void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId) = 0;
  virtual void get_mesh(std::string& _return, const metadata& vol, const vector3i& chunk, const int32_t segId) = 0;
  virtual double compare_results(const std::vector<result> & old_results, const result& new_result) = 0;
  virtual void get_seeds(std::vector<std::set<value> > & _return, const metadata& taskVolume, const std::set<value> & selected, const metadata& adjacentVolume) = 0;
  virtual void make_volume(const metadata& vol, const std::string& uri) = 0;
};

class serverNull : virtual public serverIf {
 public:
  virtual ~serverNull() {}
  void get_tile(tile& /* _return */, const metadata& /* vol */, const vector3d& /* point */, const viewType::type /* view */) {
    return;
  }
  void get_tiles(std::map<std::string, tile> & /* _return */, const metadata& /* vol */, const bbox& /* bounds */, const viewType::type /* view */, const value& /* filter */) {
    return;
  }
  void get_value(value& /* _return */, const metadata& /* vol */, const vector3d& /* point */) {
    return;
  }
  void get_values(std::set<value> & /* _return */, const metadata& /* vol */, const vector3d& /* point */, const int32_t /* radius */, const viewType::type /* view */) {
    return;
  }
  void get_seg_bbox(bbox& /* _return */, const metadata& /* vol */, const int32_t /* segId */) {
    return;
  }
  void get_mesh(std::string& /* _return */, const metadata& /* vol */, const vector3i& /* chunk */, const int32_t /* segId */) {
    return;
  }
  double compare_results(const std::vector<result> & /* old_results */, const result& /* new_result */) {
    double _return = (double)0;
    return _return;
  }
  void get_seeds(std::vector<std::set<value> > & /* _return */, const metadata& /* taskVolume */, const std::set<value> & /* selected */, const metadata& /* adjacentVolume */) {
    return;
  }
  void make_volume(const metadata& /* vol */, const std::string& /* uri */) {
    return;
  }
};

typedef struct _server_get_tile_args__isset {
  _server_get_tile_args__isset() : vol(false), point(false), view(false) {}
  bool vol;
  bool point;
  bool view;
} _server_get_tile_args__isset;

class server_get_tile_args {
 public:

  server_get_tile_args() {
  }

  virtual ~server_get_tile_args() throw() {}

  metadata vol;
  vector3d point;
  viewType::type view;

  _server_get_tile_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  bool operator == (const server_get_tile_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(view == rhs.view))
      return false;
    return true;
  }
  bool operator != (const server_get_tile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_tile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_tile_pargs {
 public:


  virtual ~server_get_tile_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;
  const viewType::type* view;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_tile_result__isset {
  _server_get_tile_result__isset() : success(false) {}
  bool success;
} _server_get_tile_result__isset;

class server_get_tile_result {
 public:

  server_get_tile_result() {
  }

  virtual ~server_get_tile_result() throw() {}

  tile success;

  _server_get_tile_result__isset __isset;

  void __set_success(const tile& val) {
    success = val;
  }

  bool operator == (const server_get_tile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_tile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_tile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_tile_presult__isset {
  _server_get_tile_presult__isset() : success(false) {}
  bool success;
} _server_get_tile_presult__isset;

class server_get_tile_presult {
 public:


  virtual ~server_get_tile_presult() throw() {}

  tile* success;

  _server_get_tile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_tiles_args__isset {
  _server_get_tiles_args__isset() : vol(false), bounds(false), view(false), filter(false) {}
  bool vol;
  bool bounds;
  bool view;
  bool filter;
} _server_get_tiles_args__isset;

class server_get_tiles_args {
 public:

  server_get_tiles_args() {
  }

  virtual ~server_get_tiles_args() throw() {}

  metadata vol;
  bbox bounds;
  viewType::type view;
  value filter;

  _server_get_tiles_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_bounds(const bbox& val) {
    bounds = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  void __set_filter(const value& val) {
    filter = val;
  }

  bool operator == (const server_get_tiles_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(bounds == rhs.bounds))
      return false;
    if (!(view == rhs.view))
      return false;
    if (!(filter == rhs.filter))
      return false;
    return true;
  }
  bool operator != (const server_get_tiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_tiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_tiles_pargs {
 public:


  virtual ~server_get_tiles_pargs() throw() {}

  const metadata* vol;
  const bbox* bounds;
  const viewType::type* view;
  const value* filter;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_tiles_result__isset {
  _server_get_tiles_result__isset() : success(false) {}
  bool success;
} _server_get_tiles_result__isset;

class server_get_tiles_result {
 public:

  server_get_tiles_result() {
  }

  virtual ~server_get_tiles_result() throw() {}

  std::map<std::string, tile>  success;

  _server_get_tiles_result__isset __isset;

  void __set_success(const std::map<std::string, tile> & val) {
    success = val;
  }

  bool operator == (const server_get_tiles_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_tiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_tiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_tiles_presult__isset {
  _server_get_tiles_presult__isset() : success(false) {}
  bool success;
} _server_get_tiles_presult__isset;

class server_get_tiles_presult {
 public:


  virtual ~server_get_tiles_presult() throw() {}

  std::map<std::string, tile> * success;

  _server_get_tiles_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_value_args__isset {
  _server_get_value_args__isset() : vol(false), point(false) {}
  bool vol;
  bool point;
} _server_get_value_args__isset;

class server_get_value_args {
 public:

  server_get_value_args() {
  }

  virtual ~server_get_value_args() throw() {}

  metadata vol;
  vector3d point;

  _server_get_value_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  bool operator == (const server_get_value_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const server_get_value_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_value_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_value_pargs {
 public:


  virtual ~server_get_value_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_value_result__isset {
  _server_get_value_result__isset() : success(false) {}
  bool success;
} _server_get_value_result__isset;

class server_get_value_result {
 public:

  server_get_value_result() {
  }

  virtual ~server_get_value_result() throw() {}

  value success;

  _server_get_value_result__isset __isset;

  void __set_success(const value& val) {
    success = val;
  }

  bool operator == (const server_get_value_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_value_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_value_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_value_presult__isset {
  _server_get_value_presult__isset() : success(false) {}
  bool success;
} _server_get_value_presult__isset;

class server_get_value_presult {
 public:


  virtual ~server_get_value_presult() throw() {}

  value* success;

  _server_get_value_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_values_args__isset {
  _server_get_values_args__isset() : vol(false), point(false), radius(false), view(false) {}
  bool vol;
  bool point;
  bool radius;
  bool view;
} _server_get_values_args__isset;

class server_get_values_args {
 public:

  server_get_values_args() : radius(0) {
  }

  virtual ~server_get_values_args() throw() {}

  metadata vol;
  vector3d point;
  int32_t radius;
  viewType::type view;

  _server_get_values_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  void __set_radius(const int32_t val) {
    radius = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  bool operator == (const server_get_values_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(radius == rhs.radius))
      return false;
    if (!(view == rhs.view))
      return false;
    return true;
  }
  bool operator != (const server_get_values_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_values_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_values_pargs {
 public:


  virtual ~server_get_values_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;
  const int32_t* radius;
  const viewType::type* view;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_values_result__isset {
  _server_get_values_result__isset() : success(false) {}
  bool success;
} _server_get_values_result__isset;

class server_get_values_result {
 public:

  server_get_values_result() {
  }

  virtual ~server_get_values_result() throw() {}

  std::set<value>  success;

  _server_get_values_result__isset __isset;

  void __set_success(const std::set<value> & val) {
    success = val;
  }

  bool operator == (const server_get_values_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_values_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_values_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_values_presult__isset {
  _server_get_values_presult__isset() : success(false) {}
  bool success;
} _server_get_values_presult__isset;

class server_get_values_presult {
 public:


  virtual ~server_get_values_presult() throw() {}

  std::set<value> * success;

  _server_get_values_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_bbox_args__isset {
  _server_get_seg_bbox_args__isset() : vol(false), segId(false) {}
  bool vol;
  bool segId;
} _server_get_seg_bbox_args__isset;

class server_get_seg_bbox_args {
 public:

  server_get_seg_bbox_args() : segId(0) {
  }

  virtual ~server_get_seg_bbox_args() throw() {}

  metadata vol;
  int32_t segId;

  _server_get_seg_bbox_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  bool operator == (const server_get_seg_bbox_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(segId == rhs.segId))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_bbox_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_bbox_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_bbox_pargs {
 public:


  virtual ~server_get_seg_bbox_pargs() throw() {}

  const metadata* vol;
  const int32_t* segId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_bbox_result__isset {
  _server_get_seg_bbox_result__isset() : success(false) {}
  bool success;
} _server_get_seg_bbox_result__isset;

class server_get_seg_bbox_result {
 public:

  server_get_seg_bbox_result() {
  }

  virtual ~server_get_seg_bbox_result() throw() {}

  bbox success;

  _server_get_seg_bbox_result__isset __isset;

  void __set_success(const bbox& val) {
    success = val;
  }

  bool operator == (const server_get_seg_bbox_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_bbox_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_bbox_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_bbox_presult__isset {
  _server_get_seg_bbox_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_bbox_presult__isset;

class server_get_seg_bbox_presult {
 public:


  virtual ~server_get_seg_bbox_presult() throw() {}

  bbox* success;

  _server_get_seg_bbox_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_mesh_args__isset {
  _server_get_mesh_args__isset() : vol(false), chunk(false), segId(false) {}
  bool vol;
  bool chunk;
  bool segId;
} _server_get_mesh_args__isset;

class server_get_mesh_args {
 public:

  server_get_mesh_args() : segId(0) {
  }

  virtual ~server_get_mesh_args() throw() {}

  metadata vol;
  vector3i chunk;
  int32_t segId;

  _server_get_mesh_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  bool operator == (const server_get_mesh_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(segId == rhs.segId))
      return false;
    return true;
  }
  bool operator != (const server_get_mesh_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mesh_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_mesh_pargs {
 public:


  virtual ~server_get_mesh_pargs() throw() {}

  const metadata* vol;
  const vector3i* chunk;
  const int32_t* segId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mesh_result__isset {
  _server_get_mesh_result__isset() : success(false) {}
  bool success;
} _server_get_mesh_result__isset;

class server_get_mesh_result {
 public:

  server_get_mesh_result() : success("") {
  }

  virtual ~server_get_mesh_result() throw() {}

  std::string success;

  _server_get_mesh_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const server_get_mesh_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_mesh_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mesh_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mesh_presult__isset {
  _server_get_mesh_presult__isset() : success(false) {}
  bool success;
} _server_get_mesh_presult__isset;

class server_get_mesh_presult {
 public:


  virtual ~server_get_mesh_presult() throw() {}

  std::string* success;

  _server_get_mesh_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_compare_results_args__isset {
  _server_compare_results_args__isset() : old_results(false), new_result(false) {}
  bool old_results;
  bool new_result;
} _server_compare_results_args__isset;

class server_compare_results_args {
 public:

  server_compare_results_args() {
  }

  virtual ~server_compare_results_args() throw() {}

  std::vector<result>  old_results;
  result new_result;

  _server_compare_results_args__isset __isset;

  void __set_old_results(const std::vector<result> & val) {
    old_results = val;
  }

  void __set_new_result(const result& val) {
    new_result = val;
  }

  bool operator == (const server_compare_results_args & rhs) const
  {
    if (!(old_results == rhs.old_results))
      return false;
    if (!(new_result == rhs.new_result))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_compare_results_pargs {
 public:


  virtual ~server_compare_results_pargs() throw() {}

  const std::vector<result> * old_results;
  const result* new_result;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_result__isset {
  _server_compare_results_result__isset() : success(false) {}
  bool success;
} _server_compare_results_result__isset;

class server_compare_results_result {
 public:

  server_compare_results_result() : success(0) {
  }

  virtual ~server_compare_results_result() throw() {}

  double success;

  _server_compare_results_result__isset __isset;

  void __set_success(const double val) {
    success = val;
  }

  bool operator == (const server_compare_results_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_presult__isset {
  _server_compare_results_presult__isset() : success(false) {}
  bool success;
} _server_compare_results_presult__isset;

class server_compare_results_presult {
 public:


  virtual ~server_compare_results_presult() throw() {}

  double* success;

  _server_compare_results_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seeds_args__isset {
  _server_get_seeds_args__isset() : taskVolume(false), selected(false), adjacentVolume(false) {}
  bool taskVolume;
  bool selected;
  bool adjacentVolume;
} _server_get_seeds_args__isset;

class server_get_seeds_args {
 public:

  server_get_seeds_args() {
  }

  virtual ~server_get_seeds_args() throw() {}

  metadata taskVolume;
  std::set<value>  selected;
  metadata adjacentVolume;

  _server_get_seeds_args__isset __isset;

  void __set_taskVolume(const metadata& val) {
    taskVolume = val;
  }

  void __set_selected(const std::set<value> & val) {
    selected = val;
  }

  void __set_adjacentVolume(const metadata& val) {
    adjacentVolume = val;
  }

  bool operator == (const server_get_seeds_args & rhs) const
  {
    if (!(taskVolume == rhs.taskVolume))
      return false;
    if (!(selected == rhs.selected))
      return false;
    if (!(adjacentVolume == rhs.adjacentVolume))
      return false;
    return true;
  }
  bool operator != (const server_get_seeds_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seeds_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seeds_pargs {
 public:


  virtual ~server_get_seeds_pargs() throw() {}

  const metadata* taskVolume;
  const std::set<value> * selected;
  const metadata* adjacentVolume;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seeds_result__isset {
  _server_get_seeds_result__isset() : success(false) {}
  bool success;
} _server_get_seeds_result__isset;

class server_get_seeds_result {
 public:

  server_get_seeds_result() {
  }

  virtual ~server_get_seeds_result() throw() {}

  std::vector<std::set<value> >  success;

  _server_get_seeds_result__isset __isset;

  void __set_success(const std::vector<std::set<value> > & val) {
    success = val;
  }

  bool operator == (const server_get_seeds_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seeds_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seeds_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seeds_presult__isset {
  _server_get_seeds_presult__isset() : success(false) {}
  bool success;
} _server_get_seeds_presult__isset;

class server_get_seeds_presult {
 public:


  virtual ~server_get_seeds_presult() throw() {}

  std::vector<std::set<value> > * success;

  _server_get_seeds_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_make_volume_args__isset {
  _server_make_volume_args__isset() : vol(false), uri(false) {}
  bool vol;
  bool uri;
} _server_make_volume_args__isset;

class server_make_volume_args {
 public:

  server_make_volume_args() : uri("") {
  }

  virtual ~server_make_volume_args() throw() {}

  metadata vol;
  std::string uri;

  _server_make_volume_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_uri(const std::string& val) {
    uri = val;
  }

  bool operator == (const server_make_volume_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const server_make_volume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_make_volume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_make_volume_pargs {
 public:


  virtual ~server_make_volume_pargs() throw() {}

  const metadata* vol;
  const std::string* uri;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class serverClient : virtual public serverIf {
 public:
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void get_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view);
  void send_get_tile(const metadata& vol, const vector3d& point, const viewType::type view);
  void recv_get_tile(tile& _return);
  void get_tiles(std::map<std::string, tile> & _return, const metadata& vol, const bbox& bounds, const viewType::type view, const value& filter);
  void send_get_tiles(const metadata& vol, const bbox& bounds, const viewType::type view, const value& filter);
  void recv_get_tiles(std::map<std::string, tile> & _return);
  void get_value(value& _return, const metadata& vol, const vector3d& point);
  void send_get_value(const metadata& vol, const vector3d& point);
  void recv_get_value(value& _return);
  void get_values(std::set<value> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view);
  void send_get_values(const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view);
  void recv_get_values(std::set<value> & _return);
  void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId);
  void send_get_seg_bbox(const metadata& vol, const int32_t segId);
  void recv_get_seg_bbox(bbox& _return);
  void get_mesh(std::string& _return, const metadata& vol, const vector3i& chunk, const int32_t segId);
  void send_get_mesh(const metadata& vol, const vector3i& chunk, const int32_t segId);
  void recv_get_mesh(std::string& _return);
  double compare_results(const std::vector<result> & old_results, const result& new_result);
  void send_compare_results(const std::vector<result> & old_results, const result& new_result);
  double recv_compare_results();
  void get_seeds(std::vector<std::set<value> > & _return, const metadata& taskVolume, const std::set<value> & selected, const metadata& adjacentVolume);
  void send_get_seeds(const metadata& taskVolume, const std::set<value> & selected, const metadata& adjacentVolume);
  void recv_get_seeds(std::vector<std::set<value> > & _return);
  void make_volume(const metadata& vol, const std::string& uri);
  void send_make_volume(const metadata& vol, const std::string& uri);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class serverProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<serverIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (serverProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_get_tile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_tiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_value(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_values(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_bbox(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_mesh(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compare_results(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seeds(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_make_volume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  serverProcessor(boost::shared_ptr<serverIf> iface) :
    iface_(iface) {
    processMap_["get_tile"] = &serverProcessor::process_get_tile;
    processMap_["get_tiles"] = &serverProcessor::process_get_tiles;
    processMap_["get_value"] = &serverProcessor::process_get_value;
    processMap_["get_values"] = &serverProcessor::process_get_values;
    processMap_["get_seg_bbox"] = &serverProcessor::process_get_seg_bbox;
    processMap_["get_mesh"] = &serverProcessor::process_get_mesh;
    processMap_["compare_results"] = &serverProcessor::process_compare_results;
    processMap_["get_seeds"] = &serverProcessor::process_get_seeds;
    processMap_["make_volume"] = &serverProcessor::process_make_volume;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~serverProcessor() {}
};

class serverMultiface : virtual public serverIf {
 public:
  serverMultiface(std::vector<boost::shared_ptr<serverIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~serverMultiface() {}
 protected:
  std::vector<boost::shared_ptr<serverIf> > ifaces_;
  serverMultiface() {}
  void add(boost::shared_ptr<serverIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void get_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_tile(_return, vol, point, view);
        return;
      } else {
        ifaces_[i]->get_tile(_return, vol, point, view);
      }
    }
  }

  void get_tiles(std::map<std::string, tile> & _return, const metadata& vol, const bbox& bounds, const viewType::type view, const value& filter) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_tiles(_return, vol, bounds, view, filter);
        return;
      } else {
        ifaces_[i]->get_tiles(_return, vol, bounds, view, filter);
      }
    }
  }

  void get_value(value& _return, const metadata& vol, const vector3d& point) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_value(_return, vol, point);
        return;
      } else {
        ifaces_[i]->get_value(_return, vol, point);
      }
    }
  }

  void get_values(std::set<value> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_values(_return, vol, point, radius, view);
        return;
      } else {
        ifaces_[i]->get_values(_return, vol, point, radius, view);
      }
    }
  }

  void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seg_bbox(_return, vol, segId);
        return;
      } else {
        ifaces_[i]->get_seg_bbox(_return, vol, segId);
      }
    }
  }

  void get_mesh(std::string& _return, const metadata& vol, const vector3i& chunk, const int32_t segId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_mesh(_return, vol, chunk, segId);
        return;
      } else {
        ifaces_[i]->get_mesh(_return, vol, chunk, segId);
      }
    }
  }

  double compare_results(const std::vector<result> & old_results, const result& new_result) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->compare_results(old_results, new_result);
      } else {
        ifaces_[i]->compare_results(old_results, new_result);
      }
    }
  }

  void get_seeds(std::vector<std::set<value> > & _return, const metadata& taskVolume, const std::set<value> & selected, const metadata& adjacentVolume) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seeds(_return, taskVolume, selected, adjacentVolume);
        return;
      } else {
        ifaces_[i]->get_seeds(_return, taskVolume, selected, adjacentVolume);
      }
    }
  }

  void make_volume(const metadata& vol, const std::string& uri) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->make_volume(vol, uri);
    }
  }

};

}} // namespace

#endif
