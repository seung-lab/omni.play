/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef server_H
#define server_H

#include <TProcessor.h>
#include "server_types.h"

namespace om { namespace common {

class serverIf {
 public:
  virtual ~serverIf() {}
  virtual void get_chan_tile(tile& _return, const vector3d& point) = 0;
  virtual void get_seg_tile(tile& _return, const vector3d& point) = 0;
  virtual void click(click_info& _return, const vector3d& point) = 0;
  virtual double compare_results(const std::vector<result> & old_results, const result& new_result) = 0;
};

class serverNull : virtual public serverIf {
 public:
  virtual ~serverNull() {}
  void get_chan_tile(tile& /* _return */, const vector3d& /* point */) {
    return;
  }
  void get_seg_tile(tile& /* _return */, const vector3d& /* point */) {
    return;
  }
  void click(click_info& /* _return */, const vector3d& /* point */) {
    return;
  }
  double compare_results(const std::vector<result> & /* old_results */, const result& /* new_result */) {
    double _return = (double)0;
    return _return;
  }
};

typedef struct _server_get_chan_tile_args__isset {
  _server_get_chan_tile_args__isset() : point(false) {}
  bool point;
} _server_get_chan_tile_args__isset;

class server_get_chan_tile_args {
 public:

  server_get_chan_tile_args() {
  }

  virtual ~server_get_chan_tile_args() throw() {}

  vector3d point;

  _server_get_chan_tile_args__isset __isset;

  void __set_point(const vector3d& val) {
    point = val;
  }

  bool operator == (const server_get_chan_tile_args & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const server_get_chan_tile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chan_tile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_chan_tile_pargs {
 public:


  virtual ~server_get_chan_tile_pargs() throw() {}

  const vector3d* point;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chan_tile_result__isset {
  _server_get_chan_tile_result__isset() : success(false) {}
  bool success;
} _server_get_chan_tile_result__isset;

class server_get_chan_tile_result {
 public:

  server_get_chan_tile_result() {
  }

  virtual ~server_get_chan_tile_result() throw() {}

  tile success;

  _server_get_chan_tile_result__isset __isset;

  void __set_success(const tile& val) {
    success = val;
  }

  bool operator == (const server_get_chan_tile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_chan_tile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chan_tile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chan_tile_presult__isset {
  _server_get_chan_tile_presult__isset() : success(false) {}
  bool success;
} _server_get_chan_tile_presult__isset;

class server_get_chan_tile_presult {
 public:


  virtual ~server_get_chan_tile_presult() throw() {}

  tile* success;

  _server_get_chan_tile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_tile_args__isset {
  _server_get_seg_tile_args__isset() : point(false) {}
  bool point;
} _server_get_seg_tile_args__isset;

class server_get_seg_tile_args {
 public:

  server_get_seg_tile_args() {
  }

  virtual ~server_get_seg_tile_args() throw() {}

  vector3d point;

  _server_get_seg_tile_args__isset __isset;

  void __set_point(const vector3d& val) {
    point = val;
  }

  bool operator == (const server_get_seg_tile_args & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_tile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_tile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_tile_pargs {
 public:


  virtual ~server_get_seg_tile_pargs() throw() {}

  const vector3d* point;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_tile_result__isset {
  _server_get_seg_tile_result__isset() : success(false) {}
  bool success;
} _server_get_seg_tile_result__isset;

class server_get_seg_tile_result {
 public:

  server_get_seg_tile_result() {
  }

  virtual ~server_get_seg_tile_result() throw() {}

  tile success;

  _server_get_seg_tile_result__isset __isset;

  void __set_success(const tile& val) {
    success = val;
  }

  bool operator == (const server_get_seg_tile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_tile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_tile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_tile_presult__isset {
  _server_get_seg_tile_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_tile_presult__isset;

class server_get_seg_tile_presult {
 public:


  virtual ~server_get_seg_tile_presult() throw() {}

  tile* success;

  _server_get_seg_tile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_click_args__isset {
  _server_click_args__isset() : point(false) {}
  bool point;
} _server_click_args__isset;

class server_click_args {
 public:

  server_click_args() {
  }

  virtual ~server_click_args() throw() {}

  vector3d point;

  _server_click_args__isset __isset;

  void __set_point(const vector3d& val) {
    point = val;
  }

  bool operator == (const server_click_args & rhs) const
  {
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const server_click_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_click_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_click_pargs {
 public:


  virtual ~server_click_pargs() throw() {}

  const vector3d* point;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_click_result__isset {
  _server_click_result__isset() : success(false) {}
  bool success;
} _server_click_result__isset;

class server_click_result {
 public:

  server_click_result() {
  }

  virtual ~server_click_result() throw() {}

  click_info success;

  _server_click_result__isset __isset;

  void __set_success(const click_info& val) {
    success = val;
  }

  bool operator == (const server_click_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_click_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_click_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_click_presult__isset {
  _server_click_presult__isset() : success(false) {}
  bool success;
} _server_click_presult__isset;

class server_click_presult {
 public:


  virtual ~server_click_presult() throw() {}

  click_info* success;

  _server_click_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_compare_results_args__isset {
  _server_compare_results_args__isset() : old_results(false), new_result(false) {}
  bool old_results;
  bool new_result;
} _server_compare_results_args__isset;

class server_compare_results_args {
 public:

  server_compare_results_args() {
  }

  virtual ~server_compare_results_args() throw() {}

  std::vector<result>  old_results;
  result new_result;

  _server_compare_results_args__isset __isset;

  void __set_old_results(const std::vector<result> & val) {
    old_results = val;
  }

  void __set_new_result(const result& val) {
    new_result = val;
  }

  bool operator == (const server_compare_results_args & rhs) const
  {
    if (!(old_results == rhs.old_results))
      return false;
    if (!(new_result == rhs.new_result))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_compare_results_pargs {
 public:


  virtual ~server_compare_results_pargs() throw() {}

  const std::vector<result> * old_results;
  const result* new_result;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_result__isset {
  _server_compare_results_result__isset() : success(false) {}
  bool success;
} _server_compare_results_result__isset;

class server_compare_results_result {
 public:

  server_compare_results_result() : success(0) {
  }

  virtual ~server_compare_results_result() throw() {}

  double success;

  _server_compare_results_result__isset __isset;

  void __set_success(const double val) {
    success = val;
  }

  bool operator == (const server_compare_results_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_presult__isset {
  _server_compare_results_presult__isset() : success(false) {}
  bool success;
} _server_compare_results_presult__isset;

class server_compare_results_presult {
 public:


  virtual ~server_compare_results_presult() throw() {}

  double* success;

  _server_compare_results_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class serverClient : virtual public serverIf {
 public:
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void get_chan_tile(tile& _return, const vector3d& point);
  void send_get_chan_tile(const vector3d& point);
  void recv_get_chan_tile(tile& _return);
  void get_seg_tile(tile& _return, const vector3d& point);
  void send_get_seg_tile(const vector3d& point);
  void recv_get_seg_tile(tile& _return);
  void click(click_info& _return, const vector3d& point);
  void send_click(const vector3d& point);
  void recv_click(click_info& _return);
  double compare_results(const std::vector<result> & old_results, const result& new_result);
  void send_compare_results(const std::vector<result> & old_results, const result& new_result);
  double recv_compare_results();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class serverProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<serverIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (serverProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_get_chan_tile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_tile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_click(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compare_results(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  serverProcessor(boost::shared_ptr<serverIf> iface) :
    iface_(iface) {
    processMap_["get_chan_tile"] = &serverProcessor::process_get_chan_tile;
    processMap_["get_seg_tile"] = &serverProcessor::process_get_seg_tile;
    processMap_["click"] = &serverProcessor::process_click;
    processMap_["compare_results"] = &serverProcessor::process_compare_results;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~serverProcessor() {}
};

class serverMultiface : virtual public serverIf {
 public:
  serverMultiface(std::vector<boost::shared_ptr<serverIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~serverMultiface() {}
 protected:
  std::vector<boost::shared_ptr<serverIf> > ifaces_;
  serverMultiface() {}
  void add(boost::shared_ptr<serverIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void get_chan_tile(tile& _return, const vector3d& point) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_chan_tile(_return, point);
        return;
      } else {
        ifaces_[i]->get_chan_tile(_return, point);
      }
    }
  }

  void get_seg_tile(tile& _return, const vector3d& point) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seg_tile(_return, point);
        return;
      } else {
        ifaces_[i]->get_seg_tile(_return, point);
      }
    }
  }

  void click(click_info& _return, const vector3d& point) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->click(_return, point);
        return;
      } else {
        ifaces_[i]->click(_return, point);
      }
    }
  }

  double compare_results(const std::vector<result> & old_results, const result& new_result) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->compare_results(old_results, new_result);
      } else {
        ifaces_[i]->compare_results(old_results, new_result);
      }
    }
  }

};

}} // namespace

#endif
