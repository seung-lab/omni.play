/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef server_H
#define server_H

#include <TProcessor.h>
#include "server_types.h"

namespace om { namespace server {

class serverIf {
 public:
  virtual ~serverIf() {}
  virtual void add_chunk(const metadata& vol, const vector3i& chunk, const std::string& data) = 0;
  virtual void delete_chunk(const metadata& vol, const vector3i& chunk) = 0;
  virtual void get_chunk(std::string& _return, const metadata& vol, const vector3i& chunk) = 0;
  virtual void get_graph(std::vector<edge> & _return, const metadata& vol) = 0;
  virtual void get_mst(std::vector<edge> & _return, const metadata& vol) = 0;
  virtual void create_segmentation(metadata& _return, const metadata& chan, const int32_t newVolId, const std::vector<std::string> & features) = 0;
  virtual void get_chan_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view) = 0;
  virtual void get_seg_tiles(std::map<std::string, tile> & _return, const metadata& vol, const int32_t segId, const bbox& segBbox, const viewType::type view) = 0;
  virtual int32_t get_seg_id(const metadata& vol, const vector3d& point) = 0;
  virtual void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId) = 0;
  virtual void get_seg_ids(std::set<int32_t> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view) = 0;
  virtual void get_mesh(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId) = 0;
  virtual void get_obj(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId) = 0;
  virtual double compare_results(const std::vector<result> & old_results, const result& new_result) = 0;
  virtual void get_seeds(std::vector<std::set<int32_t> > & _return, const metadata& taskVolume, const std::set<int32_t> & selected, const metadata& adjacentVolume) = 0;
};

class serverNull : virtual public serverIf {
 public:
  virtual ~serverNull() {}
  void add_chunk(const metadata& /* vol */, const vector3i& /* chunk */, const std::string& /* data */) {
    return;
  }
  void delete_chunk(const metadata& /* vol */, const vector3i& /* chunk */) {
    return;
  }
  void get_chunk(std::string& /* _return */, const metadata& /* vol */, const vector3i& /* chunk */) {
    return;
  }
  void get_graph(std::vector<edge> & /* _return */, const metadata& /* vol */) {
    return;
  }
  void get_mst(std::vector<edge> & /* _return */, const metadata& /* vol */) {
    return;
  }
  void create_segmentation(metadata& /* _return */, const metadata& /* chan */, const int32_t /* newVolId */, const std::vector<std::string> & /* features */) {
    return;
  }
  void get_chan_tile(tile& /* _return */, const metadata& /* vol */, const vector3d& /* point */, const viewType::type /* view */) {
    return;
  }
  void get_seg_tiles(std::map<std::string, tile> & /* _return */, const metadata& /* vol */, const int32_t /* segId */, const bbox& /* segBbox */, const viewType::type /* view */) {
    return;
  }
  int32_t get_seg_id(const metadata& /* vol */, const vector3d& /* point */) {
    int32_t _return = 0;
    return _return;
  }
  void get_seg_bbox(bbox& /* _return */, const metadata& /* vol */, const int32_t /* segId */) {
    return;
  }
  void get_seg_ids(std::set<int32_t> & /* _return */, const metadata& /* vol */, const vector3d& /* point */, const int32_t /* radius */, const viewType::type /* view */) {
    return;
  }
  void get_mesh(std::string& /* _return */, const std::string& /* uri */, const vector3i& /* chunk */, const int32_t /* segId */) {
    return;
  }
  void get_obj(std::string& /* _return */, const std::string& /* uri */, const vector3i& /* chunk */, const int32_t /* segId */) {
    return;
  }
  double compare_results(const std::vector<result> & /* old_results */, const result& /* new_result */) {
    double _return = (double)0;
    return _return;
  }
  void get_seeds(std::vector<std::set<int32_t> > & /* _return */, const metadata& /* taskVolume */, const std::set<int32_t> & /* selected */, const metadata& /* adjacentVolume */) {
    return;
  }
};

typedef struct _server_add_chunk_args__isset {
  _server_add_chunk_args__isset() : vol(false), chunk(false), data(false) {}
  bool vol;
  bool chunk;
  bool data;
} _server_add_chunk_args__isset;

class server_add_chunk_args {
 public:

  server_add_chunk_args() : data("") {
  }

  virtual ~server_add_chunk_args() throw() {}

  metadata vol;
  vector3i chunk;
  std::string data;

  _server_add_chunk_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  void __set_data(const std::string& val) {
    data = val;
  }

  bool operator == (const server_add_chunk_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const server_add_chunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_add_chunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_add_chunk_pargs {
 public:


  virtual ~server_add_chunk_pargs() throw() {}

  const metadata* vol;
  const vector3i* chunk;
  const std::string* data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_add_chunk_result {
 public:

  server_add_chunk_result() {
  }

  virtual ~server_add_chunk_result() throw() {}


  bool operator == (const server_add_chunk_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const server_add_chunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_add_chunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_add_chunk_presult {
 public:


  virtual ~server_add_chunk_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_delete_chunk_args__isset {
  _server_delete_chunk_args__isset() : vol(false), chunk(false) {}
  bool vol;
  bool chunk;
} _server_delete_chunk_args__isset;

class server_delete_chunk_args {
 public:

  server_delete_chunk_args() {
  }

  virtual ~server_delete_chunk_args() throw() {}

  metadata vol;
  vector3i chunk;

  _server_delete_chunk_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  bool operator == (const server_delete_chunk_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    return true;
  }
  bool operator != (const server_delete_chunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_delete_chunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_delete_chunk_pargs {
 public:


  virtual ~server_delete_chunk_pargs() throw() {}

  const metadata* vol;
  const vector3i* chunk;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_delete_chunk_result {
 public:

  server_delete_chunk_result() {
  }

  virtual ~server_delete_chunk_result() throw() {}


  bool operator == (const server_delete_chunk_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const server_delete_chunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_delete_chunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_delete_chunk_presult {
 public:


  virtual ~server_delete_chunk_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_chunk_args__isset {
  _server_get_chunk_args__isset() : vol(false), chunk(false) {}
  bool vol;
  bool chunk;
} _server_get_chunk_args__isset;

class server_get_chunk_args {
 public:

  server_get_chunk_args() {
  }

  virtual ~server_get_chunk_args() throw() {}

  metadata vol;
  vector3i chunk;

  _server_get_chunk_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  bool operator == (const server_get_chunk_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    return true;
  }
  bool operator != (const server_get_chunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_chunk_pargs {
 public:


  virtual ~server_get_chunk_pargs() throw() {}

  const metadata* vol;
  const vector3i* chunk;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chunk_result__isset {
  _server_get_chunk_result__isset() : success(false) {}
  bool success;
} _server_get_chunk_result__isset;

class server_get_chunk_result {
 public:

  server_get_chunk_result() : success("") {
  }

  virtual ~server_get_chunk_result() throw() {}

  std::string success;

  _server_get_chunk_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const server_get_chunk_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_chunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chunk_presult__isset {
  _server_get_chunk_presult__isset() : success(false) {}
  bool success;
} _server_get_chunk_presult__isset;

class server_get_chunk_presult {
 public:


  virtual ~server_get_chunk_presult() throw() {}

  std::string* success;

  _server_get_chunk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_graph_args__isset {
  _server_get_graph_args__isset() : vol(false) {}
  bool vol;
} _server_get_graph_args__isset;

class server_get_graph_args {
 public:

  server_get_graph_args() {
  }

  virtual ~server_get_graph_args() throw() {}

  metadata vol;

  _server_get_graph_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  bool operator == (const server_get_graph_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    return true;
  }
  bool operator != (const server_get_graph_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_graph_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_graph_pargs {
 public:


  virtual ~server_get_graph_pargs() throw() {}

  const metadata* vol;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_graph_result__isset {
  _server_get_graph_result__isset() : success(false) {}
  bool success;
} _server_get_graph_result__isset;

class server_get_graph_result {
 public:

  server_get_graph_result() {
  }

  virtual ~server_get_graph_result() throw() {}

  std::vector<edge>  success;

  _server_get_graph_result__isset __isset;

  void __set_success(const std::vector<edge> & val) {
    success = val;
  }

  bool operator == (const server_get_graph_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_graph_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_graph_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_graph_presult__isset {
  _server_get_graph_presult__isset() : success(false) {}
  bool success;
} _server_get_graph_presult__isset;

class server_get_graph_presult {
 public:


  virtual ~server_get_graph_presult() throw() {}

  std::vector<edge> * success;

  _server_get_graph_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_mst_args__isset {
  _server_get_mst_args__isset() : vol(false) {}
  bool vol;
} _server_get_mst_args__isset;

class server_get_mst_args {
 public:

  server_get_mst_args() {
  }

  virtual ~server_get_mst_args() throw() {}

  metadata vol;

  _server_get_mst_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  bool operator == (const server_get_mst_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    return true;
  }
  bool operator != (const server_get_mst_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mst_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_mst_pargs {
 public:


  virtual ~server_get_mst_pargs() throw() {}

  const metadata* vol;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mst_result__isset {
  _server_get_mst_result__isset() : success(false) {}
  bool success;
} _server_get_mst_result__isset;

class server_get_mst_result {
 public:

  server_get_mst_result() {
  }

  virtual ~server_get_mst_result() throw() {}

  std::vector<edge>  success;

  _server_get_mst_result__isset __isset;

  void __set_success(const std::vector<edge> & val) {
    success = val;
  }

  bool operator == (const server_get_mst_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_mst_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mst_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mst_presult__isset {
  _server_get_mst_presult__isset() : success(false) {}
  bool success;
} _server_get_mst_presult__isset;

class server_get_mst_presult {
 public:


  virtual ~server_get_mst_presult() throw() {}

  std::vector<edge> * success;

  _server_get_mst_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_create_segmentation_args__isset {
  _server_create_segmentation_args__isset() : chan(false), newVolId(false), features(false) {}
  bool chan;
  bool newVolId;
  bool features;
} _server_create_segmentation_args__isset;

class server_create_segmentation_args {
 public:

  server_create_segmentation_args() : newVolId(0) {
  }

  virtual ~server_create_segmentation_args() throw() {}

  metadata chan;
  int32_t newVolId;
  std::vector<std::string>  features;

  _server_create_segmentation_args__isset __isset;

  void __set_chan(const metadata& val) {
    chan = val;
  }

  void __set_newVolId(const int32_t val) {
    newVolId = val;
  }

  void __set_features(const std::vector<std::string> & val) {
    features = val;
  }

  bool operator == (const server_create_segmentation_args & rhs) const
  {
    if (!(chan == rhs.chan))
      return false;
    if (!(newVolId == rhs.newVolId))
      return false;
    if (!(features == rhs.features))
      return false;
    return true;
  }
  bool operator != (const server_create_segmentation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_create_segmentation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_create_segmentation_pargs {
 public:


  virtual ~server_create_segmentation_pargs() throw() {}

  const metadata* chan;
  const int32_t* newVolId;
  const std::vector<std::string> * features;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_create_segmentation_result__isset {
  _server_create_segmentation_result__isset() : success(false) {}
  bool success;
} _server_create_segmentation_result__isset;

class server_create_segmentation_result {
 public:

  server_create_segmentation_result() {
  }

  virtual ~server_create_segmentation_result() throw() {}

  metadata success;

  _server_create_segmentation_result__isset __isset;

  void __set_success(const metadata& val) {
    success = val;
  }

  bool operator == (const server_create_segmentation_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_create_segmentation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_create_segmentation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_create_segmentation_presult__isset {
  _server_create_segmentation_presult__isset() : success(false) {}
  bool success;
} _server_create_segmentation_presult__isset;

class server_create_segmentation_presult {
 public:


  virtual ~server_create_segmentation_presult() throw() {}

  metadata* success;

  _server_create_segmentation_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_chan_tile_args__isset {
  _server_get_chan_tile_args__isset() : vol(false), point(false), view(false) {}
  bool vol;
  bool point;
  bool view;
} _server_get_chan_tile_args__isset;

class server_get_chan_tile_args {
 public:

  server_get_chan_tile_args() {
  }

  virtual ~server_get_chan_tile_args() throw() {}

  metadata vol;
  vector3d point;
  viewType::type view;

  _server_get_chan_tile_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  bool operator == (const server_get_chan_tile_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(view == rhs.view))
      return false;
    return true;
  }
  bool operator != (const server_get_chan_tile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chan_tile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_chan_tile_pargs {
 public:


  virtual ~server_get_chan_tile_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;
  const viewType::type* view;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chan_tile_result__isset {
  _server_get_chan_tile_result__isset() : success(false) {}
  bool success;
} _server_get_chan_tile_result__isset;

class server_get_chan_tile_result {
 public:

  server_get_chan_tile_result() {
  }

  virtual ~server_get_chan_tile_result() throw() {}

  tile success;

  _server_get_chan_tile_result__isset __isset;

  void __set_success(const tile& val) {
    success = val;
  }

  bool operator == (const server_get_chan_tile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_chan_tile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_chan_tile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_chan_tile_presult__isset {
  _server_get_chan_tile_presult__isset() : success(false) {}
  bool success;
} _server_get_chan_tile_presult__isset;

class server_get_chan_tile_presult {
 public:


  virtual ~server_get_chan_tile_presult() throw() {}

  tile* success;

  _server_get_chan_tile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_tiles_args__isset {
  _server_get_seg_tiles_args__isset() : vol(false), segId(false), segBbox(false), view(false) {}
  bool vol;
  bool segId;
  bool segBbox;
  bool view;
} _server_get_seg_tiles_args__isset;

class server_get_seg_tiles_args {
 public:

  server_get_seg_tiles_args() : segId(0) {
  }

  virtual ~server_get_seg_tiles_args() throw() {}

  metadata vol;
  int32_t segId;
  bbox segBbox;
  viewType::type view;

  _server_get_seg_tiles_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  void __set_segBbox(const bbox& val) {
    segBbox = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  bool operator == (const server_get_seg_tiles_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(segId == rhs.segId))
      return false;
    if (!(segBbox == rhs.segBbox))
      return false;
    if (!(view == rhs.view))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_tiles_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_tiles_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_tiles_pargs {
 public:


  virtual ~server_get_seg_tiles_pargs() throw() {}

  const metadata* vol;
  const int32_t* segId;
  const bbox* segBbox;
  const viewType::type* view;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_tiles_result__isset {
  _server_get_seg_tiles_result__isset() : success(false) {}
  bool success;
} _server_get_seg_tiles_result__isset;

class server_get_seg_tiles_result {
 public:

  server_get_seg_tiles_result() {
  }

  virtual ~server_get_seg_tiles_result() throw() {}

  std::map<std::string, tile>  success;

  _server_get_seg_tiles_result__isset __isset;

  void __set_success(const std::map<std::string, tile> & val) {
    success = val;
  }

  bool operator == (const server_get_seg_tiles_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_tiles_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_tiles_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_tiles_presult__isset {
  _server_get_seg_tiles_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_tiles_presult__isset;

class server_get_seg_tiles_presult {
 public:


  virtual ~server_get_seg_tiles_presult() throw() {}

  std::map<std::string, tile> * success;

  _server_get_seg_tiles_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_id_args__isset {
  _server_get_seg_id_args__isset() : vol(false), point(false) {}
  bool vol;
  bool point;
} _server_get_seg_id_args__isset;

class server_get_seg_id_args {
 public:

  server_get_seg_id_args() {
  }

  virtual ~server_get_seg_id_args() throw() {}

  metadata vol;
  vector3d point;

  _server_get_seg_id_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  bool operator == (const server_get_seg_id_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_id_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_id_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_id_pargs {
 public:


  virtual ~server_get_seg_id_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_id_result__isset {
  _server_get_seg_id_result__isset() : success(false) {}
  bool success;
} _server_get_seg_id_result__isset;

class server_get_seg_id_result {
 public:

  server_get_seg_id_result() : success(0) {
  }

  virtual ~server_get_seg_id_result() throw() {}

  int32_t success;

  _server_get_seg_id_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  bool operator == (const server_get_seg_id_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_id_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_id_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_id_presult__isset {
  _server_get_seg_id_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_id_presult__isset;

class server_get_seg_id_presult {
 public:


  virtual ~server_get_seg_id_presult() throw() {}

  int32_t* success;

  _server_get_seg_id_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_bbox_args__isset {
  _server_get_seg_bbox_args__isset() : vol(false), segId(false) {}
  bool vol;
  bool segId;
} _server_get_seg_bbox_args__isset;

class server_get_seg_bbox_args {
 public:

  server_get_seg_bbox_args() : segId(0) {
  }

  virtual ~server_get_seg_bbox_args() throw() {}

  metadata vol;
  int32_t segId;

  _server_get_seg_bbox_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  bool operator == (const server_get_seg_bbox_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(segId == rhs.segId))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_bbox_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_bbox_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_bbox_pargs {
 public:


  virtual ~server_get_seg_bbox_pargs() throw() {}

  const metadata* vol;
  const int32_t* segId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_bbox_result__isset {
  _server_get_seg_bbox_result__isset() : success(false) {}
  bool success;
} _server_get_seg_bbox_result__isset;

class server_get_seg_bbox_result {
 public:

  server_get_seg_bbox_result() {
  }

  virtual ~server_get_seg_bbox_result() throw() {}

  bbox success;

  _server_get_seg_bbox_result__isset __isset;

  void __set_success(const bbox& val) {
    success = val;
  }

  bool operator == (const server_get_seg_bbox_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_bbox_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_bbox_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_bbox_presult__isset {
  _server_get_seg_bbox_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_bbox_presult__isset;

class server_get_seg_bbox_presult {
 public:


  virtual ~server_get_seg_bbox_presult() throw() {}

  bbox* success;

  _server_get_seg_bbox_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seg_ids_args__isset {
  _server_get_seg_ids_args__isset() : vol(false), point(false), radius(false), view(false) {}
  bool vol;
  bool point;
  bool radius;
  bool view;
} _server_get_seg_ids_args__isset;

class server_get_seg_ids_args {
 public:

  server_get_seg_ids_args() : radius(0) {
  }

  virtual ~server_get_seg_ids_args() throw() {}

  metadata vol;
  vector3d point;
  int32_t radius;
  viewType::type view;

  _server_get_seg_ids_args__isset __isset;

  void __set_vol(const metadata& val) {
    vol = val;
  }

  void __set_point(const vector3d& val) {
    point = val;
  }

  void __set_radius(const int32_t val) {
    radius = val;
  }

  void __set_view(const viewType::type val) {
    view = val;
  }

  bool operator == (const server_get_seg_ids_args & rhs) const
  {
    if (!(vol == rhs.vol))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(radius == rhs.radius))
      return false;
    if (!(view == rhs.view))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_ids_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_ids_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seg_ids_pargs {
 public:


  virtual ~server_get_seg_ids_pargs() throw() {}

  const metadata* vol;
  const vector3d* point;
  const int32_t* radius;
  const viewType::type* view;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_ids_result__isset {
  _server_get_seg_ids_result__isset() : success(false) {}
  bool success;
} _server_get_seg_ids_result__isset;

class server_get_seg_ids_result {
 public:

  server_get_seg_ids_result() {
  }

  virtual ~server_get_seg_ids_result() throw() {}

  std::set<int32_t>  success;

  _server_get_seg_ids_result__isset __isset;

  void __set_success(const std::set<int32_t> & val) {
    success = val;
  }

  bool operator == (const server_get_seg_ids_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seg_ids_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seg_ids_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seg_ids_presult__isset {
  _server_get_seg_ids_presult__isset() : success(false) {}
  bool success;
} _server_get_seg_ids_presult__isset;

class server_get_seg_ids_presult {
 public:


  virtual ~server_get_seg_ids_presult() throw() {}

  std::set<int32_t> * success;

  _server_get_seg_ids_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_mesh_args__isset {
  _server_get_mesh_args__isset() : uri(false), chunk(false), segId(false) {}
  bool uri;
  bool chunk;
  bool segId;
} _server_get_mesh_args__isset;

class server_get_mesh_args {
 public:

  server_get_mesh_args() : uri(""), segId(0) {
  }

  virtual ~server_get_mesh_args() throw() {}

  std::string uri;
  vector3i chunk;
  int32_t segId;

  _server_get_mesh_args__isset __isset;

  void __set_uri(const std::string& val) {
    uri = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  bool operator == (const server_get_mesh_args & rhs) const
  {
    if (!(uri == rhs.uri))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(segId == rhs.segId))
      return false;
    return true;
  }
  bool operator != (const server_get_mesh_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mesh_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_mesh_pargs {
 public:


  virtual ~server_get_mesh_pargs() throw() {}

  const std::string* uri;
  const vector3i* chunk;
  const int32_t* segId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mesh_result__isset {
  _server_get_mesh_result__isset() : success(false) {}
  bool success;
} _server_get_mesh_result__isset;

class server_get_mesh_result {
 public:

  server_get_mesh_result() : success("") {
  }

  virtual ~server_get_mesh_result() throw() {}

  std::string success;

  _server_get_mesh_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const server_get_mesh_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_mesh_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_mesh_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_mesh_presult__isset {
  _server_get_mesh_presult__isset() : success(false) {}
  bool success;
} _server_get_mesh_presult__isset;

class server_get_mesh_presult {
 public:


  virtual ~server_get_mesh_presult() throw() {}

  std::string* success;

  _server_get_mesh_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_obj_args__isset {
  _server_get_obj_args__isset() : uri(false), chunk(false), segId(false) {}
  bool uri;
  bool chunk;
  bool segId;
} _server_get_obj_args__isset;

class server_get_obj_args {
 public:

  server_get_obj_args() : uri(""), segId(0) {
  }

  virtual ~server_get_obj_args() throw() {}

  std::string uri;
  vector3i chunk;
  int32_t segId;

  _server_get_obj_args__isset __isset;

  void __set_uri(const std::string& val) {
    uri = val;
  }

  void __set_chunk(const vector3i& val) {
    chunk = val;
  }

  void __set_segId(const int32_t val) {
    segId = val;
  }

  bool operator == (const server_get_obj_args & rhs) const
  {
    if (!(uri == rhs.uri))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(segId == rhs.segId))
      return false;
    return true;
  }
  bool operator != (const server_get_obj_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_obj_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_obj_pargs {
 public:


  virtual ~server_get_obj_pargs() throw() {}

  const std::string* uri;
  const vector3i* chunk;
  const int32_t* segId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_obj_result__isset {
  _server_get_obj_result__isset() : success(false) {}
  bool success;
} _server_get_obj_result__isset;

class server_get_obj_result {
 public:

  server_get_obj_result() : success("") {
  }

  virtual ~server_get_obj_result() throw() {}

  std::string success;

  _server_get_obj_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const server_get_obj_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_obj_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_obj_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_obj_presult__isset {
  _server_get_obj_presult__isset() : success(false) {}
  bool success;
} _server_get_obj_presult__isset;

class server_get_obj_presult {
 public:


  virtual ~server_get_obj_presult() throw() {}

  std::string* success;

  _server_get_obj_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_compare_results_args__isset {
  _server_compare_results_args__isset() : old_results(false), new_result(false) {}
  bool old_results;
  bool new_result;
} _server_compare_results_args__isset;

class server_compare_results_args {
 public:

  server_compare_results_args() {
  }

  virtual ~server_compare_results_args() throw() {}

  std::vector<result>  old_results;
  result new_result;

  _server_compare_results_args__isset __isset;

  void __set_old_results(const std::vector<result> & val) {
    old_results = val;
  }

  void __set_new_result(const result& val) {
    new_result = val;
  }

  bool operator == (const server_compare_results_args & rhs) const
  {
    if (!(old_results == rhs.old_results))
      return false;
    if (!(new_result == rhs.new_result))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_compare_results_pargs {
 public:


  virtual ~server_compare_results_pargs() throw() {}

  const std::vector<result> * old_results;
  const result* new_result;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_result__isset {
  _server_compare_results_result__isset() : success(false) {}
  bool success;
} _server_compare_results_result__isset;

class server_compare_results_result {
 public:

  server_compare_results_result() : success(0) {
  }

  virtual ~server_compare_results_result() throw() {}

  double success;

  _server_compare_results_result__isset __isset;

  void __set_success(const double val) {
    success = val;
  }

  bool operator == (const server_compare_results_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_compare_results_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_compare_results_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_compare_results_presult__isset {
  _server_compare_results_presult__isset() : success(false) {}
  bool success;
} _server_compare_results_presult__isset;

class server_compare_results_presult {
 public:


  virtual ~server_compare_results_presult() throw() {}

  double* success;

  _server_compare_results_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _server_get_seeds_args__isset {
  _server_get_seeds_args__isset() : taskVolume(false), selected(false), adjacentVolume(false) {}
  bool taskVolume;
  bool selected;
  bool adjacentVolume;
} _server_get_seeds_args__isset;

class server_get_seeds_args {
 public:

  server_get_seeds_args() {
  }

  virtual ~server_get_seeds_args() throw() {}

  metadata taskVolume;
  std::set<int32_t>  selected;
  metadata adjacentVolume;

  _server_get_seeds_args__isset __isset;

  void __set_taskVolume(const metadata& val) {
    taskVolume = val;
  }

  void __set_selected(const std::set<int32_t> & val) {
    selected = val;
  }

  void __set_adjacentVolume(const metadata& val) {
    adjacentVolume = val;
  }

  bool operator == (const server_get_seeds_args & rhs) const
  {
    if (!(taskVolume == rhs.taskVolume))
      return false;
    if (!(selected == rhs.selected))
      return false;
    if (!(adjacentVolume == rhs.adjacentVolume))
      return false;
    return true;
  }
  bool operator != (const server_get_seeds_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seeds_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class server_get_seeds_pargs {
 public:


  virtual ~server_get_seeds_pargs() throw() {}

  const metadata* taskVolume;
  const std::set<int32_t> * selected;
  const metadata* adjacentVolume;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seeds_result__isset {
  _server_get_seeds_result__isset() : success(false) {}
  bool success;
} _server_get_seeds_result__isset;

class server_get_seeds_result {
 public:

  server_get_seeds_result() {
  }

  virtual ~server_get_seeds_result() throw() {}

  std::vector<std::set<int32_t> >  success;

  _server_get_seeds_result__isset __isset;

  void __set_success(const std::vector<std::set<int32_t> > & val) {
    success = val;
  }

  bool operator == (const server_get_seeds_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const server_get_seeds_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_get_seeds_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _server_get_seeds_presult__isset {
  _server_get_seeds_presult__isset() : success(false) {}
  bool success;
} _server_get_seeds_presult__isset;

class server_get_seeds_presult {
 public:


  virtual ~server_get_seeds_presult() throw() {}

  std::vector<std::set<int32_t> > * success;

  _server_get_seeds_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class serverClient : virtual public serverIf {
 public:
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  serverClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void add_chunk(const metadata& vol, const vector3i& chunk, const std::string& data);
  void send_add_chunk(const metadata& vol, const vector3i& chunk, const std::string& data);
  void recv_add_chunk();
  void delete_chunk(const metadata& vol, const vector3i& chunk);
  void send_delete_chunk(const metadata& vol, const vector3i& chunk);
  void recv_delete_chunk();
  void get_chunk(std::string& _return, const metadata& vol, const vector3i& chunk);
  void send_get_chunk(const metadata& vol, const vector3i& chunk);
  void recv_get_chunk(std::string& _return);
  void get_graph(std::vector<edge> & _return, const metadata& vol);
  void send_get_graph(const metadata& vol);
  void recv_get_graph(std::vector<edge> & _return);
  void get_mst(std::vector<edge> & _return, const metadata& vol);
  void send_get_mst(const metadata& vol);
  void recv_get_mst(std::vector<edge> & _return);
  void create_segmentation(metadata& _return, const metadata& chan, const int32_t newVolId, const std::vector<std::string> & features);
  void send_create_segmentation(const metadata& chan, const int32_t newVolId, const std::vector<std::string> & features);
  void recv_create_segmentation(metadata& _return);
  void get_chan_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view);
  void send_get_chan_tile(const metadata& vol, const vector3d& point, const viewType::type view);
  void recv_get_chan_tile(tile& _return);
  void get_seg_tiles(std::map<std::string, tile> & _return, const metadata& vol, const int32_t segId, const bbox& segBbox, const viewType::type view);
  void send_get_seg_tiles(const metadata& vol, const int32_t segId, const bbox& segBbox, const viewType::type view);
  void recv_get_seg_tiles(std::map<std::string, tile> & _return);
  int32_t get_seg_id(const metadata& vol, const vector3d& point);
  void send_get_seg_id(const metadata& vol, const vector3d& point);
  int32_t recv_get_seg_id();
  void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId);
  void send_get_seg_bbox(const metadata& vol, const int32_t segId);
  void recv_get_seg_bbox(bbox& _return);
  void get_seg_ids(std::set<int32_t> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view);
  void send_get_seg_ids(const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view);
  void recv_get_seg_ids(std::set<int32_t> & _return);
  void get_mesh(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId);
  void send_get_mesh(const std::string& uri, const vector3i& chunk, const int32_t segId);
  void recv_get_mesh(std::string& _return);
  void get_obj(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId);
  void send_get_obj(const std::string& uri, const vector3i& chunk, const int32_t segId);
  void recv_get_obj(std::string& _return);
  double compare_results(const std::vector<result> & old_results, const result& new_result);
  void send_compare_results(const std::vector<result> & old_results, const result& new_result);
  double recv_compare_results();
  void get_seeds(std::vector<std::set<int32_t> > & _return, const metadata& taskVolume, const std::set<int32_t> & selected, const metadata& adjacentVolume);
  void send_get_seeds(const metadata& taskVolume, const std::set<int32_t> & selected, const metadata& adjacentVolume);
  void recv_get_seeds(std::vector<std::set<int32_t> > & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class serverProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<serverIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (serverProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_add_chunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_delete_chunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_chunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_graph(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_mst(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_segmentation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_chan_tile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_tiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_bbox(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_ids(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_mesh(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_obj(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compare_results(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seeds(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  serverProcessor(boost::shared_ptr<serverIf> iface) :
    iface_(iface) {
    processMap_["add_chunk"] = &serverProcessor::process_add_chunk;
    processMap_["delete_chunk"] = &serverProcessor::process_delete_chunk;
    processMap_["get_chunk"] = &serverProcessor::process_get_chunk;
    processMap_["get_graph"] = &serverProcessor::process_get_graph;
    processMap_["get_mst"] = &serverProcessor::process_get_mst;
    processMap_["create_segmentation"] = &serverProcessor::process_create_segmentation;
    processMap_["get_chan_tile"] = &serverProcessor::process_get_chan_tile;
    processMap_["get_seg_tiles"] = &serverProcessor::process_get_seg_tiles;
    processMap_["get_seg_id"] = &serverProcessor::process_get_seg_id;
    processMap_["get_seg_bbox"] = &serverProcessor::process_get_seg_bbox;
    processMap_["get_seg_ids"] = &serverProcessor::process_get_seg_ids;
    processMap_["get_mesh"] = &serverProcessor::process_get_mesh;
    processMap_["get_obj"] = &serverProcessor::process_get_obj;
    processMap_["compare_results"] = &serverProcessor::process_compare_results;
    processMap_["get_seeds"] = &serverProcessor::process_get_seeds;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~serverProcessor() {}
};

class serverMultiface : virtual public serverIf {
 public:
  serverMultiface(std::vector<boost::shared_ptr<serverIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~serverMultiface() {}
 protected:
  std::vector<boost::shared_ptr<serverIf> > ifaces_;
  serverMultiface() {}
  void add(boost::shared_ptr<serverIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void add_chunk(const metadata& vol, const vector3i& chunk, const std::string& data) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->add_chunk(vol, chunk, data);
    }
  }

  void delete_chunk(const metadata& vol, const vector3i& chunk) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->delete_chunk(vol, chunk);
    }
  }

  void get_chunk(std::string& _return, const metadata& vol, const vector3i& chunk) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_chunk(_return, vol, chunk);
        return;
      } else {
        ifaces_[i]->get_chunk(_return, vol, chunk);
      }
    }
  }

  void get_graph(std::vector<edge> & _return, const metadata& vol) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_graph(_return, vol);
        return;
      } else {
        ifaces_[i]->get_graph(_return, vol);
      }
    }
  }

  void get_mst(std::vector<edge> & _return, const metadata& vol) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_mst(_return, vol);
        return;
      } else {
        ifaces_[i]->get_mst(_return, vol);
      }
    }
  }

  void create_segmentation(metadata& _return, const metadata& chan, const int32_t newVolId, const std::vector<std::string> & features) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->create_segmentation(_return, chan, newVolId, features);
        return;
      } else {
        ifaces_[i]->create_segmentation(_return, chan, newVolId, features);
      }
    }
  }

  void get_chan_tile(tile& _return, const metadata& vol, const vector3d& point, const viewType::type view) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_chan_tile(_return, vol, point, view);
        return;
      } else {
        ifaces_[i]->get_chan_tile(_return, vol, point, view);
      }
    }
  }

  void get_seg_tiles(std::map<std::string, tile> & _return, const metadata& vol, const int32_t segId, const bbox& segBbox, const viewType::type view) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seg_tiles(_return, vol, segId, segBbox, view);
        return;
      } else {
        ifaces_[i]->get_seg_tiles(_return, vol, segId, segBbox, view);
      }
    }
  }

  int32_t get_seg_id(const metadata& vol, const vector3d& point) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->get_seg_id(vol, point);
      } else {
        ifaces_[i]->get_seg_id(vol, point);
      }
    }
  }

  void get_seg_bbox(bbox& _return, const metadata& vol, const int32_t segId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seg_bbox(_return, vol, segId);
        return;
      } else {
        ifaces_[i]->get_seg_bbox(_return, vol, segId);
      }
    }
  }

  void get_seg_ids(std::set<int32_t> & _return, const metadata& vol, const vector3d& point, const int32_t radius, const viewType::type view) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seg_ids(_return, vol, point, radius, view);
        return;
      } else {
        ifaces_[i]->get_seg_ids(_return, vol, point, radius, view);
      }
    }
  }

  void get_mesh(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_mesh(_return, uri, chunk, segId);
        return;
      } else {
        ifaces_[i]->get_mesh(_return, uri, chunk, segId);
      }
    }
  }

  void get_obj(std::string& _return, const std::string& uri, const vector3i& chunk, const int32_t segId) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_obj(_return, uri, chunk, segId);
        return;
      } else {
        ifaces_[i]->get_obj(_return, uri, chunk, segId);
      }
    }
  }

  double compare_results(const std::vector<result> & old_results, const result& new_result) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->compare_results(old_results, new_result);
      } else {
        ifaces_[i]->compare_results(old_results, new_result);
      }
    }
  }

  void get_seeds(std::vector<std::set<int32_t> > & _return, const metadata& taskVolume, const std::set<int32_t> & selected, const metadata& adjacentVolume) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_seeds(_return, taskVolume, selected, adjacentVolume);
        return;
      } else {
        ifaces_[i]->get_seeds(_return, taskVolume, selected, adjacentVolume);
      }
    }
  }

};

}} // namespace

#endif
