
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "RealTimeMesher.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <server/TThreadPoolServer.h>
#include <server/TNonblockingServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>
#include "rtm.hpp"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::zi::mesh;

class RealTimeMesherHandler : virtual public RealTimeMesherIf {
private:
    zi::mesh::rtm rtm_;
    zi::rwmutex   m_  ;

 public:
  RealTimeMesherHandler() {
    // Your initialization goes here
  }

  bool queueUpdateChunk(const std::string& uri, const Vector3i& chunk, const std::string& data) {
    // Your implementation goes here
      //sleep(1);
      printf("queueUpdateChunk\n");
      return true;
  }

  bool updateChunk(const std::string& uri, const Vector3i& chunk, const std::string& data) {
    // Your implementation goes here
      //sleep(1);
      printf("updateChunk\n");
      return true;
  }

  bool queueUpdate(const std::string& uri, const Vector3i& location, const Vector3i& size, const std::string& data) {
    // Your implementation goes here
      zi::rwmutex::write_guard g(m_);

      rtm_.volume_update(location.x, location.y, location.z,
                         size.x, size.y, size.z,
                         data.data());

    printf("queueUpdate\n");
      return true;
  }

  bool update(const std::string& uri, const Vector3i& location, const Vector3i& size, const std::string& data) {
    // Your implementation goes here
      zi::rwmutex::write_guard g(m_);

      std::cout << "Update: " << size.x << ' ' << size.y << ' ' << size.z
                << "  " << (size.x*size.y*size.z) << " but " << data.size() << std::endl;

      rtm_.volume_update(location.x, location.y, location.z,
                         size.x, size.y, size.z,
                         data.data());

    printf("update\n");
      return true;
  }

  bool remesh(const bool sync) {
    // Your implementation goes here
      printf("remesh\n");
      return true;
  }

  void getMesh(MeshDataResult& _return, const std::string& uri, const MeshCoordinate& c) {
    // Your implementation goes here
      //zi::rwmutex::read_guard g(m_);

      zi::mesh::mesh_io.read_degenerate(zi::mesh::vec5u(c.x, c.y, c.z, c.mip, c.segID), _return.mesh.data);

      if ( _return.mesh.data == "" )
          _return.code = MeshResultCode::MISSING;
      printf("getMesh\n");
  }

  void getMeshes(std::vector<MeshDataResult> & _return, const std::string& uri, const std::vector<MeshCoordinate> & coordinates) {
    // Your implementation goes here
    printf("getMeshes\n");
    _return.resize(coordinates.size());
    for ( std::size_t i = 0; i < coordinates.size(); ++i )
    {
        _return[i].code = MeshResultCode::MISSING;
        _return[i].mesh.data = "";
    }
  }

  void getMeshIfNewer(MeshDataResult& _return, const std::string& uri, const MeshCoordinate& coordinate, const int64_t version) {
    // Your implementation goes here
      printf("getMeshIfNewer\n");
  }

  void getMeshesIfNewer(std::vector<MeshDataResult> & _return, const std::string& uri, const std::vector<MeshCoordinate> & coordinates, const std::vector<int64_t> & versions) {
    // Your implementation goes here
    printf("getMeshesIfNewer\n");
  }

  int64_t getMeshVersion(const std::string& uri, const MeshCoordinate& coordinate) {
    // Your implementation goes here
      printf("getMeshVersion\n");
      return 1;
  }

  void getMeshVersions(std::vector<int64_t> & _return, const std::string& uri, const std::vector<MeshCoordinate> & coordinates) {
    // Your implementation goes here
      printf("getMeshVersions\n");
      _return.resize(coordinates.size());
      for ( std::size_t i = 0; i < coordinates.size(); ++i ) _return[i] = 1;
  }

};

int main(int argc, char **argv) {
  int port = 9099;
  shared_ptr<RealTimeMesherHandler> handler(new RealTimeMesherHandler());
  shared_ptr<TProcessor> processor(new RealTimeMesherProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  boost::shared_ptr<ThreadManager> threadManager(ThreadManager::newSimpleThreadManager(32));
  boost::shared_ptr<PosixThreadFactory> threadFactory(new PosixThreadFactory());

    threadManager->threadFactory(threadFactory);
    threadManager->start();

  boost::shared_ptr<TNonblockingServer> server(
      new TNonblockingServer(processor, transportFactory, transportFactory,
                             protocolFactory, protocolFactory, port, threadManager));

  //handler->setServer(server); // For Service Shutdown
  //handler->setThreadManager(threadManager); // For thread busyness checking
  server->serve();

  // TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  // server.serve();
  return 0;
}

